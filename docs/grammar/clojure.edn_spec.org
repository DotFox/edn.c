#+title: EDN Spec implemented by clojure.edn
#+INCLUDE: "./edn_spec.org::edn_nil" src ebnf
#+INCLUDE: "./edn_spec.org::edn_boolean" src ebnf
#+INCLUDE: "./edn_spec.org::edn_float" src ebnf
#+INCLUDE: "./edn_spec.org::edn_list" src ebnf
#+INCLUDE: "./edn_spec.org::edn_vector" src ebnf
#+INCLUDE: "./edn_spec.org::edn_set" src ebnf
#+INCLUDE: "./edn_spec.org::edn_discard" src ebnf

* General considerations

Additional characters treated as whitespace: (~\u000B~, ~\u000C~, ~\u001C~, ~\u001D~, ~\u001E~, ~\u001F~)

#+name: edn_document
#+begin_src ebnf :eval no :exports code
Edn = { Spacing | EdnElement | ? End of input ? }- ;

Spacing = { WhiteSpace | Comment | "," }- ;

WhiteSpace = " "      (* U+0020 SPACE *)
           | "\t"     (* U+0009 HORIZONTAL TABULATION *)
           | "\n"     (* U+000A LINE FEED *)
           | "\u000B" (* U+000B VERTICAL TABULATION *)
           | "\f"     (* U+000C FORM FEED *)
           | "\r"     (* U+000D CARRIAGE RETURN *)
           | "\u001C" (* U+001C FILE SEPARATOR *)
           | "\u001D" (* U+001D GROUP SEPARATOR *)
           | "\u001E" (* U+001E RECORD SEPARATOR *)
           | "\u001F" (* U+001F UNIT SEPARATOR *)
           ;

Comment = ";" , { ( ? Any character ? - LineEnd ) } , LineEnd ;

LineEnd = "\n" | "\r" | ? End of input ? ;
#+end_src

#+begin_src plantuml :file clojure.edn_document.svg :noweb yes :exports results
@startebnf
!theme amiga
<<edn_document>>
@endebnf
#+end_src

#+RESULTS:
[[file:clojure.edn_document.svg]]

* Built-in elements

#+name: edn_elements
#+begin_src ebnf :eval no :exports code
EdnElement = Character        (* Additional named characters and octal form *)
           | String           (* Additional octal escape sequence *)
           | Float
           | Ratio            (* Rational ratios *)
           | Integer          (* Additional integer forms and minor deviations *)
           | List
           | Vector
           | Map              (* Additional syntax for namespaced maps *)
           | Set
           | Symbolic         (* ##Inf, ##-Inf, and ##NaN *)
           | TaggedElement
           | DiscardSequence
           | MetadataSequence (* Metadata literal for some EdnElements *)
           | Symbol           (* Many small additions and deviations *)
           | Nil
           | Boolean
           | Keyword          (* Same as Symbols *)
           ;
#+end_src

#+begin_src plantuml :file edn_elements.svg :noweb yes :exports results
@startebnf
!theme amiga
<<edn_elements>>
@endebnf
#+end_src

#+RESULTS:
[[file:edn_elements.svg]]

** Character

#+name: edn_character
#+begin_src ebnf :eval no :exports code
Character = "\" , ( CharLiteral | CharName | UnicodeEscape | OctalEscape ) ;

CharLiteral = ? Any character ? - WhiteSpace ;

CharName = "newline" | "space" | "tab" | "return" | "formfeed" | "backspace" ;

UnicodeEscape = "u" , HexDigit , HexDigit , HexDigit , HexDigit ;

HexDigit = ? 0-9, a-z, A-Z ? ;

OctalEscape = "o", ZeroToThree , OctalDigit , OctalDigit ;

OctalDigit = ? 0-7 ? ;

ZeroToThree = ? 0-3 ? ;
#+end_src

#+begin_src plantuml :file ./clojure.edn_character.svg :noweb yes :exports results
@startebnf
!theme amiga
<<edn_character>>
@endebnf
#+end_src

#+RESULTS:
[[file:./clojure.edn_character.svg]]

** String

#+name: edn_string
#+begin_src ebnf :eval no :exports code
String = '"' , { StringCharacter } , '"' ;

StringCharacter = InputCharacter
                | EscapeSequence ;

InputCharacter = ? Any character ? - ( "\" | '"' ) ;

EscapeSequence = "\" , ( ( "\" | '"' | "n" | "r" | "t" | "b" | "f" )
                       | UnicodeEscape
                       | ( ZeroToThree , OctalDigit , OctalDigit ) ) ;
#+end_src

#+begin_src plantuml :file ./clojure.edn_string.svg :noweb yes :exports results
@startebnf
!theme amiga
<<edn_string>>
@endebnf
#+end_src

#+RESULTS:
[[file:./clojure.edn_string.svg]]

** Symbolic

#+name: edn_symbolic
#+begin_src ebnf :eval no :exports code
Symbolic = "##Inf" | "##-Inf" | "NaN" ;
#+end_src

#+begin_src plantuml :file ./clojure.edn_symbolic.svg :noweb yes :exports results
@startebnf
!theme amiga
<<edn_symbolic>>
@endebnf
#+end_src

#+RESULTS:
[[file:./clojure.edn_symbolic.svg]]

** Symbol

#+name: edn_symbol
#+begin_src ebnf :eval no :exports code
Symbol = Identifier - ( Nil | Boolean ) ;

Identifier = SymbolPrefix , "/" , IdentifierName
           | SymbolPrefix
           | "/" ;

(* SymbolPrefix can't contain repeating ":" *)
SymbolPrefix = ( IdentifierStart - ( "+" | "-" | "." ) ) , [ { SymbolPrefixBody } , IdentifierEnd ]
             | ( "+" | "-" | "." ) , [ ( SymbolPrefixBody - ? Decimal digit ? ) , [ { SymbolPrefixBody } , IdentifierEnd ] ] ;

(* IdentifierName can't contain repeating ":" *)
IdentifierName = ( IdentifierConstituent - ? DecimalDigit ? ) , [ { IdentifierConstituent } , IdentifierEnd ] ;

IdentifierStart = IdentifierConstituent - ( ? Decimal digit ? | ":" | "/" ) ;

IdentifierEnd = IdentifierConstituent - ( ":" | "/" ) ;

SymbolPrefixBody = IdentifierConstituent - "/" ;

IdentifierConstituent = ? Any char ? - ( WhiteSpace | "," | ";" | StructuralDelimiter | "`" | "@" | "~" ) ;

StructuralDelimiter = '"'
                    | "\\"
                    | "[" | "]"
                    | "{" | "}"
                    | "(" | ")"
                    | "#" ;
#+end_src

#+begin_src plantuml :file ./clojure.edn_symbol.svg :noweb yes :exports results
@startebnf
!theme amiga
<<edn_symbol>>
@endebnf
#+end_src

#+RESULTS:
[[file:./clojure.edn_symbol.svg]]

** Keyword

#+name: edn_keyword
#+begin_src ebnf :eval no :exports code
Keyword = ":" , KeywordIdentifier ;

KeywordIdentifier = KeywordPrefix , "/" , IdentifierName
                  | KeywordPrefix
                  | "/" ;

(* KeywordPrefix can't contain repeating ":" *)
KeywordPrefix = IdentifierConstituent - "/" , [ { IdentifierConstituent } , IdentifierEnd ] ;
#+end_src

#+begin_src plantuml :file ./clojure.edn_keyword.svg :noweb yes :exports results
@startebnf
!theme amiga
<<edn_keyword>>
@endebnf
#+end_src

#+RESULTS:
[[file:./clojure.edn_keyword.svg]]

** Integer

#+name: edn_integer
#+begin_src ebnf :eval no :exports code
Integer = [ "-" | "+" ] , ( OctalInteger
                          | HexadecimalInteger
                          | RadixInteger
                          | DecimalInteger ) ;

DecimalInteger = ( ( ? Decimal digit ? - "0" , { ? Decimal digit ? } ) | "0" ) , [ "N" ] ;

OctalInteger = "0" , { OctalDigit }- ;

HexadecimalInteger = "0x" , { HexDigit }- , [ "N" ] ;

RadixInteger = Radix , "r" , { RadixDigit }- ;

Radix = ( ? Decimal digit ? - ( "0" | "1" ) )
      | ( "2" , ? Decimal digit ? )
      | ( "3" , ZeroToSix ) ;

RadixDigit = ? 0-9, a-z, A-Z ? ;
ZeroToSix = ? 0-6 ? ;
#+end_src

#+begin_src plantuml :file ./clojure.edn_integer.svg :noweb yes :exports results
@startebnf
!theme amiga
<<edn_integer>>
@endebnf
#+end_src

#+RESULTS:
[[file:./clojure.edn_integer.svg]]

** Ratio

#+name: edn_ratio
#+begin_src ebnf :eval no :exports code
Ratio = [ "-" | "+" ] , ( ( ? Decimal digit ? - "0" , { ? Decimal digit ? } ) | "0" ) , "/" , ( ? Decimal digit ? - "0" , { ? Decimal digit ? } ) ;
#+end_src

#+begin_src plantuml :file ./clojure.edn_ratio.svg :noweb yes :exports results
@startebnf
!theme amiga
<<edn_ratio>>
@endebnf
#+end_src

#+RESULTS:
[[file:./clojure.edn_ratio.svg]]

** Map

#+name: edn_map
#+begin_src ebnf :eval no :exports code
Map = [ "#:" , KeywordPrefix ] , "{" , { Spacing | MapEntry } , "}" ;

MapEntry = ReadableEdnElement , [ Spacing ] , ReadableEdnElement ;

ReadableEdnElement = ( EdnElement - DiscardSequence )
                   | DiscardSequence , [ Spacing ] , ReadableEdnElement ;
#+end_src

#+begin_src plantuml :file ./clojure.edn_map.svg :noweb yes :exports results
@startebnf
!theme amiga
<<edn_map>>
@endebnf
#+end_src

#+RESULTS:
[[file:./clojure.edn_map.svg]]

** Tagged

#+name: edn_tagged
#+begin_src ebnf :eval no :exports code
TaggedElement = "#" , Symbol , [ Spacing ] , ReadableEdnElement ;

(* built-in tagged elements *)

Instant = "#inst" , [ Spacing ] , ? RFC-3339 formatted string ? ;

UUID = "#uuid" , [ Spacing ] , ? Canonical UUID string representation ? ;
#+end_src

#+begin_src plantuml :file ./clojure.edn_tagged.svg :noweb yes :exports results
@startebnf
!theme amiga
<<edn_tagged>>
@endebnf
#+end_src

#+RESULTS:
[[file:./clojure.edn_tagged.svg]]

** MetadataSequence

#+name: edn_metadata
#+begin_src ebnf :eval no :exports code
MetadataSequence = "^" , [ Spacing ] , ReadableEdnElement , [ Spacing ] , ReadableEdnElement ;

Metadata = String
         | Keyword
         | Symbol
         | Map ;
#+end_src

#+begin_src plantuml :file ./clojure.edn_metadata.svg :noweb yes :exports results
@startebnf
!theme amiga
<<edn_metadata>>
@endebnf
#+end_src

#+RESULTS:
[[file:./clojure.edn_metadata.svg]]

* Complete EBNF Grammar

#+name: edn_ebnf
#+begin_src ebnf :eval no :noweb yes :exports results :tangle clojure.edn_grammar.ebnf
<<edn_document>>

<<edn_elements>>

<<edn_nil>>

<<edn_boolean>>

<<edn_character>>

<<edn_string>>

<<edn_symbolic>>

<<edn_symbol>>

<<edn_keyword>>

<<edn_integer>>

<<edn_ratio>>

<<edn_float>>

<<edn_list>>

<<edn_vector>>

<<edn_map>>

<<edn_set>>

<<edn_discard>>

<<edn_metadata>>

<<edn_tagged>>
#+end_src

#+RESULTS:
[[file:edn_grammar.ebnf]]

#+begin_src plantuml :file ./clojure.edn_ebnf.svg :noweb yes :exports results
@startebnf
!theme amiga
title EDN grammar implemented by clojure.edn

(* Assumes greedy repetition
   Assumes ordered alternation *)

<<edn_ebnf>>

@endebnf
#+end_src

#+RESULTS:
[[file:./clojure.edn_ebnf.svg]]
